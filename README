Things are *messy* right now; I'm in the midst of yet another code
reorganization in preparation to adding shared memory and "real-time"
output.


Basic:

Allow catching connections "late" meaning that the SYN packet(s) were
not seen.  This would allow "pickup" of already-established connections
at runtime.  (Partially implemented.)

Allow run-time selection of what addresses to monitor, and (eventual)
optional specification of a tty for each address' data to be printed on.
This is currently accomplished via piping from 'tcpdump'.

Allow run-time selection of what destination (only) ports to monitor,
and optional specification of a tty for each port's data to be printed
on.  (The tty bit is not yet supported, and may not be for some time;
I've got bigger fish to fry right now.)  The tty-per-port (and
tty-per-address?) option(s) will probably be mutually exclusive, at
least initially.


Later:

Addresses can be specified as either source or destination addresses
(for the packets in question), and will be matched with the packet
addresses somehow; e.g. via netmasks.


Eventual:

Tty's/filters will be written to by fork()'d processes that will have
the data passed to them by the "master" sniffer via IPC of some sort
(most likely shared memory).  This keeps the master in the read() loop
as much as possible, which is critical under Linux [see next note].

A real-time (packet-by-packet), switchable, etc., ncurses-based
front-end for flexibility.

Add a bpf-like module to Linux to keep at least the high-level filtering
in the kernel and away from userland.  Already discussed this with Alan
Cox, who likes the idea.  It will also provide buffering, which is
sorely needed under Linux to prevent "missing" packets.

Real-time remote transfer of the sniffed data via some sort of encrypted
network channel.
